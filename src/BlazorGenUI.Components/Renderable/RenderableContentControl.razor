
@using BlazorGenUI.Reflection.Interfaces
@using BlazorGenUI.Reflection.Enums
@using BlazorGenUI.Reflection.Attributes
@using BlazorGenUI.Components.Layouts

<h3>RenderableContentControl</h3>

<LayoutView Layout="@LayoutType">
@RenderComponent(Wrapper);
</LayoutView>


@code
{
    public RenderFragment RenderComponent(IComplexElement complexElement) => __builder =>
    {

        var typeAttribute = GetAttribute<TemplateAttribute>(complexElement.EncapsulatedDto);

        var component = ViewComplexLocatorBuilder(typeAttribute);

        if (component != null && !OnlyRecursive)
        {
            @CreateComplexComponent(complexElement, component);
        }
        else
        {
            @RenderKids(complexElement)
        }
    };


    RenderFragment RenderKids(IComplexElement complexElement) => __builder =>
    {
        var kids = complexElement.GetChildren();
        foreach (var kid in kids)
        {
           
            
            <LayoutSetter LayoutType="@LayoutType"
                          ChildContent="@Generator(kid)"></LayoutSetter>
            //@Generator(kid)
        }

    };


    RenderFragment Generator(IBaseElement kid) => __builder =>
    {

        if (kid is IValueElement primitiveKid)
        {
            @GeneratePrimitive(primitiveKid)
        }
        else
        {
            IComplexElement complexKid = (IComplexElement)kid;
            @GenerateComplex(complexKid)
        }


    };

    private RenderFragment GeneratePrimitive(IValueElement kid) => __builder =>
    {

        var primitiveKidType = kid.PropertyType;
        

        var primitiveComponent = ViewBaseLocatorBuilder(primitiveKidType.Name, Presentation);
    //if component not found, use BaseGenericComponent
        if (primitiveComponent == null)
        {
            bool isEnum = kid.PropertyType.IsEnum;
            var baseName = kid.RawName;
            var genericTypeArg = kid.PropertyType;
                
            primitiveComponent = ViewGenericBaseLocatorBuilder(baseName, Presentation, genericTypeArg, isEnum);
        }

        @CreatePrimitiveComponent(kid, primitiveComponent)




    };

    private RenderFragment GenerateComplex(IComplexElement complexElement) => __builder =>
    {
        var typeAttribute = GetAttribute<TemplateAttribute>(complexElement);

        var component = ViewComplexLocatorBuilder(typeAttribute);

        if (component != null && !OnlyRecursive)
        {
            @CreateComplexComponent(complexElement, component)
        }
        else
        {
            @RenderKids(complexElement)
        }
    };

    private RenderFragment CreatePrimitiveComponent(IValueElement value, IRenderableComponent primitiveComponent) => __builder =>
    {
        __builder.OpenComponent(1, primitiveComponent.GetType());
        __builder.AddAttribute(2, "ValueElement", value);
        __builder.CloseComponent();
    };

    private RenderFragment CreateComplexComponent(IComplexElement complex, IRenderableComponent component) => __builder =>
    {
        __builder.OpenComponent(0, component.GetType());
        __builder.AddAttribute(1, "ComplexObject", complex);
        __builder.CloseComponent();
    };
}